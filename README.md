# Suff Tree Ukkonen's algorithm
- Талалуев Денис Сергеевич.
- ВУЗ - Двфу.
- Направление - Б9121-09.03.03пикд.
- Год - 2022.
- Алгоритм - Построение суффисного дерева алгоритмом Укконена.

----------------------------------------------------------
# Содержание
- [Глоссарий]
- [Вступление]
     - [Задача Online поиск шаблонов в тексте]
     - [Основная идея алгоритма заключается в нескольких модификациях]
     - [Как же предобработать текст?]
- [Основополагающая идея: построить суффиксное дерево(бор на суффиксах)]
- [Сжатое Суффиксное дерево]
- [Построение сжатого суффиксного дерева]
    - [Алгоритм]
    - [Операция добавления символа]
- [Положения]
  - [Первый тип]
  - [Второй тип]
  - [Третий тип]
  - [Изменение типов]
- [Переход от положения к положению:Суффиксная ссылка]
  - [Как создавать суффиксные ссылки?]
  - [Рассмотрим применение суффиксных ссылок]
- [Структура дерева]
- [Реалицазия]    
    - [Конструктор Узла]
    - [Деструктор]
    - [Функция построения дерева]
    - [Расширение суффиксного дерева]
- [Список литературы]

------------------------------------------------
## Глоссарий
- __`Строка (text)`__ - это массив последовательных символов
- __`Подстрока`__ – это часть строки, состоящая из некоторого количества смежных символов исходной строки.
- __`Суффикс`__ - это подстрока строки __S__, начинающеяся в позиции __i__ и зканчивающеяся в __m-1__ - где __m__ это длина строки __S__. Представляется как __S[i..m-1]__.
Например суффиксы строки __"abcab"__ представлены ниже в таблице.

- __`Суффиксный дерево(бор)`__ - дерево, содержащие все суффиксы некоторой строки (и только их).
                                                  Позволяет выяснять, входит ли строка w в исходную строку t, за время О (|w|), где |w| — длина подстроки w.
- __`Сжатое суффиксное дерево`__ - это оптимизация дерева путем склеивания ребер без развилок в одно, значение этого ребра становится подстрока, подстрока предствалсяется ввиде двух указателей на начало и конец подстроки в строке.

- __`Суффиксная ссылка`__ - Суффиксная ссылка вершины v называется указатель на вершину u, такую что стока u – является наибольшим суффиксом строки v, который уже есть в дереве (строку считаем от корня до самой вершины).

- __`Активная точка`__ - это переменная которая состоит из 3 значений (активная вершина, активное ребро, активная длина), эта точка указывает на символ на ребре от которого строится развилка.

- __`Активная вершина`__ - это вершина из которой выходит ребро с активной точкой, обозначается индексом вершины.

- __`Активное ребро`__ - это ребро ив которой находится активная точка, обозначается первым символом подстроки в ребре.

- __`Активная длина`__ - расстояние, на котором находится активная вершина от начала ребра.

- __`Текущий конец(#)`__ - переменная, хранящая в себе индекс текущего конца подстроки (индекс символа, на котором выполняется алгоритм в данный момент), эта переменная нужна для автоматического продления суффиксов.

----------------------------------------
## Вступление
***Алгоритм Укконена*** — алгоритм построения суффиксного дерева за линейным время,
 который изобрел Эско Укконен в 1995 году.

Алгоритм, который изобрел Эско Укконен для построения суффиксного дерева за линейное время можно представить сначала как простой,
 но неэффективный метод, который с помощью нескольких приёмов достигает уровня лучших алгоритмов по времени счёта в наихудших условиях.


---

## Постановка задачи

Дана строка __S__. Требуется построить сжатое суффиксное дерево данной строки за линейное время и дать доступ ко всем суффиксам строки.

---

## Особенности алгоритма

- Асимтотическая сложность алгоритма = О(n).
- Количество затраченной памяти = O(n).
- Значения хранящиеся в ребрах являются подстроками ввиде указателей на начало и конец подстрок.
- Использование суффиксных ссылок.
---

## Описание работы алгоритма

### Подготовка

Для правильной работы алгоритмы перед началом к строке добавляется уникальный символ, принято использовать символ __'$'__.

Активная точка устанавливается (корень, /n , 0);

### Оснавная работа алгоритма

На каждом шаге алгоитм читаем символ строки и проверяет существует ли ребро исходящее из активной вершины, ничинаещееся на прочитанный символ.

Если нет, то из активной вершины создается ребро и его значения устаниваливаются (индекс прочитанного символа, #).

Если есть, то прочитанный символ добавляется в очередь

---


